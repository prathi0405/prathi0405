# -*- coding: utf-8 -*-
"""MNIST 20AD032.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1P2r2virnd8g04-6kra9OrDgF58ncwQfK

install gradio
"""

!pip install gradio(interface for our ml model)

"""gradio package is imported"""

import gradio as gr

"""numpy,tensorflow,matplotlib packages needed are imported"""

import tensorflow as tf
from matplotlib import pyplot as plt
import numpy as np

"""loading mnist dataset from keras library
splitting dataset into testing and training
"""

objects =  tf.keras.datasets.mnist
(training_images, training_labels), (test_images, test_labels) = objects.load_data()

"""just plotting the dataset"""

for i in range(9):
	# define subplot
	plt.subplot(330 + 1 + i)
	# plot raw pixel data
	plt.imshow(training_images[i])

""" scaling the image so that the pixels of image are in range of 0 to 1"""

training_images  = training_images / 255.0
test_images = test_images / 255.0

"""#model building
flatten(),dense() function are imported from tensorflow.keras.layers;
tf.keras.models.sequential() function adds layers in sequential layer
flatten as input layer;
3 hidden layers as dense with relu avtivation function;
output layer with softmax which classifies

"""

from tensorflow.keras.layers import Flatten, Dense
model = tf.keras.models.Sequential([Flatten(input_shape=(28,28)), 
                                    Dense(256, activation='relu'),
                                    Dense(256, activation='relu'),
                                    Dense(128, activation='relu'), 
                                    Dense(10, activation=tf.nn.softmax)])

"""performing optimizing,loss and calculating metrics"""

model.compile(optimizer = 'adam',
              loss = 'sparse_categorical_crossentropy',
              metrics=['accuracy'])

"""training the model with 10 epochs"""

model.fit(training_images, training_labels, epochs=10)

"""fetch single image from testing set and reshape it.
predict it with model
"""

test=test_images[0].reshape(-1,28,28)
pred=model.predict(test)
print(pred)

"""accept any image as input and reshape and resize it
then predict it with the model
"""

def predict_image(img):
  img_3d=img.reshape(-1,28,28)
  im_resize=img_3d/255.0
  prediction=model.predict(im_resize)
  pred=np.argmax(prediction)
  return pred

"""integration of the webapp.
interface of the python function predict_image.assign sketchpad as input
"""

iface = gr.Interface(predict_image, inputs="sketchpad", outputs="label")

"""launch the interface"""

iface.launch(debug='True')